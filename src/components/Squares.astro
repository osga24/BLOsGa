---
export interface Props {
  direction?: "diagonal" | "up" | "right" | "down" | "left";
  speed?: number;
  borderColor?: string;
  squareSize?: number;
  hoverFillColor?: string;
  class?: string;
}

const {
  direction = "right",
  speed = 1,
  borderColor = "#999",
  squareSize = 40,
  hoverFillColor = "#222",
  class: className = "",
} = Astro.props;
---

<canvas class={`squares-canvas ${className}`}></canvas>

<style>
  .squares-canvas {
    width: 100%;
    height: 100%;
    border: none;
    display: block;
  }
</style>

<script define:vars={{ direction, speed, borderColor, squareSize, hoverFillColor }}>
  class SquaresAnimation {
    constructor(canvas, options) {
      this.canvas = canvas;
      this.ctx = canvas.getContext("2d");
      this.direction = options.direction || "right";
      this.speed = options.speed || 1;
      this.borderColor = options.borderColor || "#999";
      this.squareSize = options.squareSize || 40;
      this.hoverFillColor = options.hoverFillColor || "#222";
      
      this.requestRef = null;
      this.numSquaresX = 0;
      this.numSquaresY = 0;
      this.gridOffset = { x: 0, y: 0 };
      this.hoveredSquare = null;
      
      this.init();
    }

    init() {
      this.resizeCanvas();
      this.setupEventListeners();
      this.startAnimation();
    }

    resizeCanvas() {
      this.canvas.width = this.canvas.offsetWidth;
      this.canvas.height = this.canvas.offsetHeight;
      this.numSquaresX = Math.ceil(this.canvas.width / this.squareSize) + 1;
      this.numSquaresY = Math.ceil(this.canvas.height / this.squareSize) + 1;
    }

    drawGrid() {
      if (!this.ctx) return;

      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

      const startX = Math.floor(this.gridOffset.x / this.squareSize) * this.squareSize;
      const startY = Math.floor(this.gridOffset.y / this.squareSize) * this.squareSize;

      for (let x = startX; x < this.canvas.width + this.squareSize; x += this.squareSize) {
        for (let y = startY; y < this.canvas.height + this.squareSize; y += this.squareSize) {
          const squareX = x - (this.gridOffset.x % this.squareSize);
          const squareY = y - (this.gridOffset.y % this.squareSize);

          if (
            this.hoveredSquare &&
            Math.floor((x - startX) / this.squareSize) === this.hoveredSquare.x &&
            Math.floor((y - startY) / this.squareSize) === this.hoveredSquare.y
          ) {
            this.ctx.fillStyle = this.hoverFillColor;
            this.ctx.fillRect(squareX, squareY, this.squareSize, this.squareSize);
          }

          this.ctx.strokeStyle = this.borderColor;
          this.ctx.strokeRect(squareX, squareY, this.squareSize, this.squareSize);
        }
      }

      // 添加径向渐变覆盖层
      const gradient = this.ctx.createRadialGradient(
        this.canvas.width / 2,
        this.canvas.height / 2,
        0,
        this.canvas.width / 2,
        this.canvas.height / 2,
        Math.sqrt(this.canvas.width ** 2 + this.canvas.height ** 2) / 2
      );
      gradient.addColorStop(0, "rgba(0, 0, 0, 0)");
      gradient.addColorStop(1, "#060010");

      this.ctx.fillStyle = gradient;
      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }

    updateAnimation() {
      const effectiveSpeed = Math.max(this.speed, 0.1);
      
      switch (this.direction) {
        case "right":
          this.gridOffset.x = (this.gridOffset.x - effectiveSpeed + this.squareSize) % this.squareSize;
          break;
        case "left":
          this.gridOffset.x = (this.gridOffset.x + effectiveSpeed + this.squareSize) % this.squareSize;
          break;
        case "up":
          this.gridOffset.y = (this.gridOffset.y + effectiveSpeed + this.squareSize) % this.squareSize;
          break;
        case "down":
          this.gridOffset.y = (this.gridOffset.y - effectiveSpeed + this.squareSize) % this.squareSize;
          break;
        case "diagonal":
          this.gridOffset.x = (this.gridOffset.x - effectiveSpeed + this.squareSize) % this.squareSize;
          this.gridOffset.y = (this.gridOffset.y - effectiveSpeed + this.squareSize) % this.squareSize;
          break;
        default:
          break;
      }

      this.drawGrid();
      this.requestRef = requestAnimationFrame(() => this.updateAnimation());
    }

    handleMouseMove(event) {
      const rect = this.canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;

      const startX = Math.floor(this.gridOffset.x / this.squareSize) * this.squareSize;
      const startY = Math.floor(this.gridOffset.y / this.squareSize) * this.squareSize;

      const hoveredSquareX = Math.floor((mouseX + this.gridOffset.x - startX) / this.squareSize);
      const hoveredSquareY = Math.floor((mouseY + this.gridOffset.y - startY) / this.squareSize);

      if (
        !this.hoveredSquare ||
        this.hoveredSquare.x !== hoveredSquareX ||
        this.hoveredSquare.y !== hoveredSquareY
      ) {
        this.hoveredSquare = { x: hoveredSquareX, y: hoveredSquareY };
      }
    }

    handleMouseLeave() {
      this.hoveredSquare = null;
    }

    setupEventListeners() {
      const resizeHandler = () => this.resizeCanvas();
      const mouseMoveHandler = (e) => this.handleMouseMove(e);
      const mouseLeaveHandler = () => this.handleMouseLeave();

      window.addEventListener("resize", resizeHandler);
      this.canvas.addEventListener("mousemove", mouseMoveHandler);
      this.canvas.addEventListener("mouseleave", mouseLeaveHandler);

      // 清理函数存储到canvas上，以便在组件卸载时使用
      this.canvas._cleanup = () => {
        window.removeEventListener("resize", resizeHandler);
        this.canvas.removeEventListener("mousemove", mouseMoveHandler);
        this.canvas.removeEventListener("mouseleave", mouseLeaveHandler);
        if (this.requestRef) {
          cancelAnimationFrame(this.requestRef);
        }
      };
    }

    startAnimation() {
      this.requestRef = requestAnimationFrame(() => this.updateAnimation());
    }

    destroy() {
      if (this.canvas._cleanup) {
        this.canvas._cleanup();
      }
    }
  }

  // 初始化动画
  document.addEventListener("DOMContentLoaded", () => {
    const canvas = document.querySelector(".squares-canvas");
    if (canvas) {
      const animation = new SquaresAnimation(canvas, {
        direction,
        speed,
        borderColor,
        squareSize,
        hoverFillColor,
      });

      // 存储动画实例到canvas上，以便后续清理
      canvas._animation = animation;
    }
  });

  // 页面卸载时清理
  window.addEventListener("beforeunload", () => {
    const canvas = document.querySelector(".squares-canvas");
    if (canvas && canvas._animation) {
      canvas._animation.destroy();
    }
  });
</script>
